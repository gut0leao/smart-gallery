name: "2. Provision infrastructure üèóÔ∏è"

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: 'GCP Project ID'
        required: true
        type: string
      domain_name:
        description: 'Domain name (e.g., smartgallery.exemplo.com or mysite.duckdns.org)'
        required: true
        type: string
      use_duckdns:
        description: 'Use Duck DNS for automatic DNS management'
        required: false
        default: false
        type: boolean
      duckdns_subdomain:
        description: 'Duck DNS subdomain (only the part before .duckdns.org)'
        required: false
        type: string
      environment:
        description: 'Environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      region:
        description: 'GCP Region'
        required: false
        default: 'us-central1'
        type: string
      machine_type:
        description: 'VM Machine Type'
        required: false
        default: 'e2-micro'
        type: choice
        options:
          - e2-micro
          - e2-small
          - e2-medium

env:
  TF_VERSION: '1.6.0'
  GCP_PROJECT_ID: ${{ github.event.inputs.project_id }}
  DOMAIN_NAME: ${{ github.event.inputs.domain_name }}
  ENVIRONMENT: ${{ github.event.inputs.environment }}
  USE_DUCKDNS: ${{ github.event.inputs.use_duckdns }}
  DUCKDNS_SUBDOMAIN: ${{ github.event.inputs.duckdns_subdomain }}

jobs:
  provision:
    name: üèóÔ∏è Terraform Provision
    runs-on: ubuntu-latest
    
    outputs:
      vm_name: ${{ steps.extract_outputs.outputs.vm_name }}
      vm_zone: ${{ steps.extract_outputs.outputs.vm_zone }}
      vm_external_ip: ${{ steps.extract_outputs.outputs.vm_external_ip }}
      site_url: ${{ steps.extract_outputs.outputs.site_url }}
    
    steps:
      # Checkout repository
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      # Setup Terraform
      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      # Authenticate to GCP
      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      # Setup Google Cloud SDK
      - name: ‚òÅÔ∏è Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      # Generate SSH key for VM access
      - name: üîë Generate SSH Key
        run: |
          mkdir -p ~/.ssh
          if [ ! -f ~/.ssh/id_rsa ]; then
            ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N ""
            echo "‚úÖ SSH key generated"
          fi
          
          # Store public key for later use
          echo "SSH_PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)" >> $GITHUB_ENV

      # Terraform Init
      - name: üèóÔ∏è Terraform Init
        working-directory: terraform
        run: |
          terraform init -upgrade
          echo "‚úÖ Terraform initialized"

      # Check for existing resources and import if needed
      - name: üîç Check Existing Resources & Import
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
          TF_VAR_zone: ${{ github.event.inputs.region }}-a
        run: |
          echo "üîç Checking for existing resources and importing if needed..."
          
          # Set environment variables for resource names
          NAME_PREFIX="smart-gallery-${{ env.ENVIRONMENT }}"
          ZONE="${{ github.event.inputs.region }}-a"
          
          # Enhanced function to safely import resources with better error handling
          safe_import() {
            local resource_type="$1"
            local resource_name="$2"
            local gcp_resource_id="$3"
            local gcp_command="$4"
            local resource_display_name="$5"
            
            echo "üîç Checking $resource_display_name..."
            
            # First check if resource exists in Terraform state
            if terraform state show "$resource_type.$resource_name" >/dev/null 2>&1; then
              echo "‚úÖ $resource_display_name already managed by Terraform"
              
              # Verify the resource still exists in GCP
              if eval "$gcp_command" >/dev/null 2>&1; then
                echo "‚úÖ $resource_display_name confirmed in GCP"
              else
                echo "‚ö†Ô∏è $resource_display_name in Terraform state but not in GCP - will be recreated"
                terraform state rm "$resource_type.$resource_name" || true
              fi
              return 0
            fi
            
            # Check if resource exists in GCP
            if eval "$gcp_command" >/dev/null 2>&1; then
              echo "üì• Found existing $resource_display_name in GCP - importing..."
              
              # Attempt to import the resource
              if terraform import "$resource_type.$resource_name" "$gcp_resource_id" 2>/dev/null; then
                echo "‚úÖ Successfully imported $resource_display_name"
              else
                echo "‚ö†Ô∏è Import failed for $resource_display_name"
                echo "üîÑ This usually means resource configuration doesn't match"
                echo "üìã Resource will be recreated with correct configuration"
              fi
            else
              echo "‚ûï $resource_display_name will be created (not found in GCP)"
            fi
          }
          
          # Function to check VM status and avoid unnecessary recreation
          check_vm_status() {
            local vm_name="$1"
            local zone="$2"
            
            if gcloud compute instances describe "$vm_name" --zone="$zone" --format="value(status)" 2>/dev/null; then
              VM_STATUS=$(gcloud compute instances describe "$vm_name" --zone="$zone" --format="value(status)" 2>/dev/null)
              VM_MACHINE_TYPE=$(gcloud compute instances describe "$vm_name" --zone="$zone" --format="value(machineType)" 2>/dev/null | sed 's|.*/||')
              VM_DISK_SIZE=$(gcloud compute instances describe "$vm_name" --zone="$zone" --format="value(disks[0].diskSizeGb)" 2>/dev/null)
              
              echo "üìä VM Status Report:"
              echo "  ‚Ä¢ Status: $VM_STATUS"
              echo "  ‚Ä¢ Machine Type: $VM_MACHINE_TYPE"
              echo "  ‚Ä¢ Disk Size: ${VM_DISK_SIZE}GB"
              echo "  ‚Ä¢ Requested Type: ${{ github.event.inputs.machine_type }}"
              
              # Check if VM configuration matches requirements
              if [ "$VM_MACHINE_TYPE" = "${{ github.event.inputs.machine_type }}" ]; then
                echo "‚úÖ VM configuration matches requirements"
                return 0
              else
                echo "‚ö†Ô∏è VM machine type differs from requested"
                echo "üîÑ VM will be updated to match configuration"
                return 1
              fi
            else
              echo "‚ûï VM not found - will be created"
              return 2
            fi
          }
          
          # Import network resources
          echo "üåê Checking Network Resources..."
          safe_import "google_compute_network" "smart_gallery_network" \
            "projects/${{ env.GCP_PROJECT_ID }}/global/networks/$NAME_PREFIX-network" \
            "gcloud compute networks describe '$NAME_PREFIX-network' --project='${{ env.GCP_PROJECT_ID }}' --quiet" \
            "VPC Network"
          
          safe_import "google_compute_subnetwork" "smart_gallery_subnet" \
            "projects/${{ env.GCP_PROJECT_ID }}/regions/${{ github.event.inputs.region }}/subnetworks/$NAME_PREFIX-subnet" \
            "gcloud compute networks subnets describe '$NAME_PREFIX-subnet' --region='${{ github.event.inputs.region }}' --project='${{ env.GCP_PROJECT_ID }}' --quiet" \
            "Subnet"
          
          # Import static IP
          echo "üåç Checking Static IP..."
          safe_import "google_compute_address" "smart_gallery_ip" \
            "projects/${{ env.GCP_PROJECT_ID }}/regions/${{ github.event.inputs.region }}/addresses/$NAME_PREFIX-ip" \
            "gcloud compute addresses describe '$NAME_PREFIX-ip' --region='${{ github.event.inputs.region }}' --project='${{ env.GCP_PROJECT_ID }}' --quiet" \
            "Static IP"
          
          # Enhanced VM check and import
          echo "üñ•Ô∏è Checking VM Instance..."
          if check_vm_status "$NAME_PREFIX-vm" "$ZONE"; then
            # VM exists and configuration matches - try to import
            if ! terraform state show "google_compute_instance.smart_gallery_vm" >/dev/null 2>&1; then
              echo "üì• Importing existing VM..."
              
              if terraform import "google_compute_instance.smart_gallery_vm" \
                "projects/${{ env.GCP_PROJECT_ID }}/zones/$ZONE/instances/$NAME_PREFIX-vm" 2>/dev/null; then
                echo "‚úÖ VM imported successfully"
              else
                echo "‚ö†Ô∏è VM import failed - configuration may differ"
                echo "üîÑ VM will be managed but may require updates"
              fi
            else
              echo "‚úÖ VM already in Terraform state"
            fi
          fi
          
          # Import firewall rules
          echo "üî• Checking Firewall Rules..."
          declare -A fw_rules=(
            ["ssh"]="smart_gallery_ssh"
            ["http"]="smart_gallery_http"
            ["https"]="smart_gallery_https"
            ["icmp"]="smart_gallery_icmp"
          )
          
          for fw_type in "${!fw_rules[@]}"; do
            tf_resource_name="${fw_rules[$fw_type]}"
            gcp_rule_name="$NAME_PREFIX-allow-$fw_type"
            
            safe_import "google_compute_firewall" "$tf_resource_name" \
              "projects/${{ env.GCP_PROJECT_ID }}/global/firewalls/$gcp_rule_name" \
              "gcloud compute firewall-rules describe '$gcp_rule_name' --project='${{ env.GCP_PROJECT_ID }}' --quiet" \
              "Firewall Rule ($fw_type)"
          done
          
          echo "‚úÖ Resource import process completed"
          
          # Show current state summary
          echo ""
          echo "üìã Current Terraform State Summary:"
          terraform state list 2>/dev/null | sort || echo "No resources in state yet"

      # Terraform Plan with detailed analysis
      - name: üìã Terraform Plan & Analysis
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
          TF_VAR_zone: ${{ github.event.inputs.region }}-a
        run: |
          echo "üìã Creating Terraform plan with detailed analysis..."
          
          # Create plan with detailed output (don't exit on code 2)
          set +e  # Disable exit on error temporarily
          PLAN_OUTPUT=$(terraform plan -out=tfplan -detailed-exitcode 2>&1)
          PLAN_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Save plan output for analysis
          echo "$PLAN_OUTPUT" > plan_output.txt
          
          # Analyze the plan
          echo "üîç Analyzing Terraform plan..."
          
          # Check for destructive operations
          if echo "$PLAN_OUTPUT" | grep -q "must be replaced\|will be destroyed"; then
            echo "‚ö†Ô∏è DESTRUCTIVE OPERATIONS DETECTED!"
            echo ""
            echo "üìä Resources that will be DESTROYED/REPLACED:"
            echo "$PLAN_OUTPUT" | grep -A 2 -B 2 "must be replaced\|will be destroyed" || true
            echo ""
            echo "ü§î Common reasons for resource replacement:"
            echo "  ‚Ä¢ VM machine type change"
            echo "  ‚Ä¢ Network configuration change"
            echo "  ‚Ä¢ Disk configuration change"
            echo "  ‚Ä¢ Zone change"
            echo ""
            
            # Check specifically for VM replacement
            if echo "$PLAN_OUTPUT" | grep -q "google_compute_instance.*must be replaced"; then
              echo "ÔøΩÔ∏è VM REPLACEMENT DETECTED!"
              echo ""
              echo "üí° To avoid VM replacement, ensure:"
              echo "  ‚Ä¢ Machine type matches existing VM"
              echo "  ‚Ä¢ Zone matches existing VM location"
              echo "  ‚Ä¢ Network configuration is consistent"
              echo ""
              echo "üõ†Ô∏è You can modify the VM after creation if needed:"
              echo "  ‚Ä¢ Stop VM: gcloud compute instances stop VM_NAME --zone=ZONE"
              echo "  ‚Ä¢ Change type: gcloud compute instances set-machine-type VM_NAME --machine-type=NEW_TYPE --zone=ZONE"
              echo "  ‚Ä¢ Start VM: gcloud compute instances start VM_NAME --zone=ZONE"
            fi
          fi
          
          # Check for creation operations
          if echo "$PLAN_OUTPUT" | grep -q "will be created"; then
            echo "‚ûï NEW RESOURCES TO CREATE:"
            echo "$PLAN_OUTPUT" | grep -A 1 "will be created" | grep "^  #" || true
            echo ""
          fi
          
          # Check for updates
          if echo "$PLAN_OUTPUT" | grep -q "will be updated in-place"; then
            echo "üîÑ RESOURCES TO UPDATE IN-PLACE:"
            echo "$PLAN_OUTPUT" | grep -A 1 "will be updated in-place" | grep "^  #" || true
            echo ""
          fi
          
          # Handle plan exit codes
          case $PLAN_EXIT_CODE in
            0)
              echo "‚úÖ No changes needed - infrastructure is up to date!"
              echo "PLAN_HAS_CHANGES=false" >> $GITHUB_ENV
              ;;
            1)
              echo "‚ùå Terraform plan failed!"
              echo ""
              echo "üìã Plan output:"
              echo "----------------------------------------"
              cat plan_output.txt
              echo "----------------------------------------"
              echo ""
              echo "üîç This usually indicates:"
              echo "‚Ä¢ Syntax errors in Terraform configuration"
              echo "‚Ä¢ Missing required variables"
              echo "‚Ä¢ Authentication or permission issues"
              echo "‚Ä¢ Invalid resource configurations"
              exit 1
              ;;
            2)
              echo "üìù Changes detected - plan created successfully"
              echo "PLAN_HAS_CHANGES=true" >> $GITHUB_ENV
              
              # Count operations with safer parsing
              CREATE_COUNT=$(echo "$PLAN_OUTPUT" | grep -c "will be created" 2>/dev/null || echo "0")
              UPDATE_COUNT=$(echo "$PLAN_OUTPUT" | grep -c "will be updated in-place" 2>/dev/null || echo "0")
              REPLACE_COUNT=$(echo "$PLAN_OUTPUT" | grep -c "must be replaced" 2>/dev/null || echo "0")
              DESTROY_COUNT=$(echo "$PLAN_OUTPUT" | grep -c "will be destroyed" 2>/dev/null || echo "0")
              
              # Validate counts are numbers
              CREATE_COUNT=${CREATE_COUNT//[^0-9]/}
              UPDATE_COUNT=${UPDATE_COUNT//[^0-9]/}
              REPLACE_COUNT=${REPLACE_COUNT//[^0-9]/}
              DESTROY_COUNT=${DESTROY_COUNT//[^0-9]/}
              
              # Set defaults if empty
              CREATE_COUNT=${CREATE_COUNT:-0}
              UPDATE_COUNT=${UPDATE_COUNT:-0}
              REPLACE_COUNT=${REPLACE_COUNT:-0}
              DESTROY_COUNT=${DESTROY_COUNT:-0}
              
              echo ""
              echo "üìä PLAN SUMMARY:"
              echo "  ‚Ä¢ Resources to create: $CREATE_COUNT"
              echo "  ‚Ä¢ Resources to update: $UPDATE_COUNT"
              echo "  ‚Ä¢ Resources to replace: $REPLACE_COUNT"
              echo "  ‚Ä¢ Resources to destroy: $DESTROY_COUNT"
              
              # Store counts for later use with safe values
              {
                echo "CREATE_COUNT=$CREATE_COUNT"
                echo "UPDATE_COUNT=$UPDATE_COUNT"
                echo "REPLACE_COUNT=$REPLACE_COUNT"
                echo "DESTROY_COUNT=$DESTROY_COUNT"
              } >> $GITHUB_ENV
              ;;
          esac
          
          echo ""
          echo "‚úÖ Terraform plan analysis completed"

      # Terraform Apply with safeguards
      - name: üöÄ Terraform Apply
        id: terraform
        if: env.PLAN_HAS_CHANGES == 'true'
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
          TF_VAR_zone: ${{ github.event.inputs.region }}-a
        run: |
          echo "üöÄ Applying Terraform configuration..."
          
          # Show what will be applied with safe variable handling
          REPLACE_COUNT=${REPLACE_COUNT:-0}
          DESTROY_COUNT=${DESTROY_COUNT:-0}
          
          if [ "$REPLACE_COUNT" -gt 0 ] || [ "$DESTROY_COUNT" -gt 0 ]; then
            TOTAL_DESTRUCTIVE=$((REPLACE_COUNT + DESTROY_COUNT))
            echo "‚ö†Ô∏è  DESTRUCTIVE OPERATIONS WARNING!"
            echo "This will destroy/replace $TOTAL_DESTRUCTIVE resources"
            echo ""
            echo "üíæ Before proceeding, consider backing up important data:"
            echo "  ‚Ä¢ Database content"  
            echo "  ‚Ä¢ WordPress files"
            echo "  ‚Ä¢ SSL certificates"
            echo "  ‚Ä¢ Configuration files"
            echo ""
          fi
          
          # Apply the plan
          if [ -f tfplan ]; then
            echo "üìã Applying planned changes..."
            terraform apply -auto-approve tfplan
          else
            echo "‚ö†Ô∏è No plan file found, this shouldn't happen..."
            echo "Running direct apply as fallback..."
            terraform apply -auto-approve
          fi
          
          echo "‚úÖ Terraform apply completed!"
      
      # Handle case where no changes needed
      - name: ‚ÑπÔ∏è No Changes Needed  
        if: env.PLAN_HAS_CHANGES == 'false'
        working-directory: terraform
        run: |
          echo "‚úÖ Infrastructure is already up to date!"
          echo "üìã Current resources are matching the desired configuration"
          
          # Still extract outputs for consistency
          echo "üì§ Extracting current infrastructure information..."
          
      # Extract outputs (works for both apply and no-changes scenarios)  
      - name: üì§ Extract Infrastructure Information
        id: extract_outputs
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
          TF_VAR_zone: ${{ github.event.inputs.region }}-a
        run: |
          echo "üì§ Extracting infrastructure information..."
          
          NAME_PREFIX="smart-gallery-${{ env.ENVIRONMENT }}"
          ZONE="${{ github.event.inputs.region }}-a"
          
          # Function to get outputs with intelligent fallback
          get_infrastructure_info() {
            echo "üîç Gathering infrastructure details..."
            
            # Try Terraform outputs first
            if terraform output vm_name >/dev/null 2>&1; then
              VM_NAME=$(terraform output -raw vm_name)
              echo "‚úÖ VM name from Terraform: $VM_NAME"
            else
              VM_NAME="$NAME_PREFIX-vm"
              echo "üìã VM name constructed: $VM_NAME"
            fi
            
            if terraform output vm_zone >/dev/null 2>&1; then
              VM_ZONE=$(terraform output -raw vm_zone)
              echo "‚úÖ VM zone from Terraform: $VM_ZONE"
            else
              VM_ZONE="$ZONE"
              echo "üìã VM zone constructed: $VM_ZONE"
            fi
            
            # For IP, try multiple methods
            VM_IP=""
            if terraform output vm_external_ip >/dev/null 2>&1; then
              VM_IP=$(terraform output -raw vm_external_ip)
              echo "‚úÖ VM IP from Terraform: $VM_IP"
            else
              # Try to get IP from GCP directly
              echo "üîç Querying VM IP from GCP..."
              VM_IP=$(gcloud compute instances describe "$VM_NAME" \
                --zone="$VM_ZONE" \
                --format="get(networkInterfaces[0].accessConfigs[0].natIP)" 2>/dev/null || echo "")
              
              if [ -n "$VM_IP" ]; then
                echo "‚úÖ VM IP from GCP: $VM_IP"
              else
                # Try static IP if VM query failed
                echo "üîç Trying to get static IP..."
                VM_IP=$(gcloud compute addresses describe "$NAME_PREFIX-ip" \
                  --region="${{ github.event.inputs.region }}" \
                  --format="get(address)" 2>/dev/null || echo "")
                
                if [ -n "$VM_IP" ]; then
                  echo "‚úÖ Static IP found: $VM_IP"
                else
                  echo "‚ö†Ô∏è Could not determine VM IP"
                  VM_IP="unknown"
                fi
              fi
            fi
            
            # Site URL
            if terraform output site_url >/dev/null 2>&1; then
              SITE_URL=$(terraform output -raw site_url)
              echo "‚úÖ Site URL from Terraform: $SITE_URL"
            else
              SITE_URL="https://${{ env.DOMAIN_NAME }}"
              echo "üìã Site URL constructed: $SITE_URL"
            fi
            
            # Verify VM actually exists and is accessible
            echo "üîç Verifying VM status..."
            if gcloud compute instances describe "$VM_NAME" --zone="$VM_ZONE" --format="value(status)" 2>/dev/null; then
              VM_STATUS=$(gcloud compute instances describe "$VM_NAME" --zone="$VM_ZONE" --format="value(status)" 2>/dev/null)
              echo "‚úÖ VM Status: $VM_STATUS"
            else
              echo "‚ö†Ô∏è VM not found or not accessible"
              VM_STATUS="unknown"
            fi
            
            # Output to GitHub Actions
            echo "vm_name=$VM_NAME" >> $GITHUB_OUTPUT
            echo "vm_zone=$VM_ZONE" >> $GITHUB_OUTPUT  
            echo "vm_external_ip=$VM_IP" >> $GITHUB_OUTPUT
            echo "site_url=$SITE_URL" >> $GITHUB_OUTPUT
            
            # Also set as environment variables for later steps
            echo "VM_NAME=$VM_NAME" >> $GITHUB_ENV
            echo "VM_ZONE=$VM_ZONE" >> $GITHUB_ENV
            echo "VM_EXTERNAL_IP=$VM_IP" >> $GITHUB_ENV
            echo "SITE_URL=$SITE_URL" >> $GITHUB_ENV
            
            echo ""
            echo "üìä Infrastructure Summary:"
            echo "  ‚Ä¢ VM Name: $VM_NAME"
            echo "  ‚Ä¢ VM Zone: $VM_ZONE"
            echo "  ‚Ä¢ VM Status: $VM_STATUS"
            echo "  ‚Ä¢ External IP: $VM_IP"
            echo "  ‚Ä¢ Site URL: $SITE_URL"
            echo ""
          }
          
          # Execute the function
          get_infrastructure_info
          
          if [ "${{ env.PLAN_HAS_CHANGES }}" = "true" ]; then
            echo "‚úÖ Infrastructure changes applied successfully!"
          else
            echo "‚úÖ Infrastructure information extracted from existing resources!"
          fi

      # Wait for VM to be ready
      - name: ‚è≥ Wait for VM Startup
        env:
          VM_NAME: ${{ steps.extract_outputs.outputs.vm_name }}
          VM_ZONE: ${{ steps.extract_outputs.outputs.vm_zone }}
        run: |
          echo "‚è≥ Waiting for VM to complete startup..."
          
          # Wait up to 5 minutes for startup script completion
          for i in {1..30}; do
            if gcloud compute ssh $VM_NAME \
              --zone=$VM_ZONE \
              --command="test -f /var/log/startup-completed" \
              --quiet 2>/dev/null; then
              echo "‚úÖ VM startup completed!"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ö†Ô∏è Startup script may still be running"
              gcloud compute ssh $VM_NAME \
                --zone=$VM_ZONE \
                --command="tail -20 /var/log/startup-script.log" \
                --quiet || echo "Could not check startup log"
            fi
            
            echo "Waiting... (${i}/30)"
            sleep 10
          done

      # Configure Duck DNS automatically (if enabled)
      - name: ü¶Ü Configure Duck DNS
        if: env.USE_DUCKDNS == 'true'
        env:
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
          DUCKDNS_TOKEN: ${{ secrets.DUCKDNS_TOKEN }}
        run: |
          if [ -z "$DUCKDNS_TOKEN" ]; then
            echo "‚ùå DUCKDNS_TOKEN secret not found!"
            echo "Please add your Duck DNS token as a repository secret named DUCKDNS_TOKEN"
            echo "Get your token from: https://www.duckdns.org/"
            exit 1
          fi
          
          if [ -z "$DUCKDNS_SUBDOMAIN" ]; then
            echo "‚ùå Duck DNS subdomain not provided!"
            exit 1
          fi
          
          # Validate subdomain format (no special chars, reasonable length)
          if [[ ! "$DUCKDNS_SUBDOMAIN" =~ ^[a-zA-Z0-9-]{1,63}$ ]]; then
            echo "‚ùå Invalid Duck DNS subdomain format: $DUCKDNS_SUBDOMAIN"
            echo "Subdomain must contain only letters, numbers, and hyphens (1-63 chars)"
            echo "Examples: mysite, smart-gallery, test123"
            exit 1
          fi
          
          echo "ü¶Ü Configuring Duck DNS for $DUCKDNS_SUBDOMAIN.duckdns.org..."
          echo "üìç Setting IP to: $VM_IP"
          echo "üîç Using token: ${DUCKDNS_TOKEN:0:8}... (masked)"
          
          # Test Duck DNS API first
          echo "üß™ Testing Duck DNS API connectivity..."
          TEST_RESPONSE=$(curl -s -w "%{http_code}" -o /dev/null "https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=$DUCKDNS_TOKEN&txt=test")
          if [ "$TEST_RESPONSE" != "200" ]; then
            echo "‚ùå Cannot reach Duck DNS API. HTTP status: $TEST_RESPONSE"
            echo "Please check your internet connection or try again later"
            exit 1
          fi
          
          # Update Duck DNS with detailed error handling
          echo "üîÑ Updating Duck DNS record..."
          RESPONSE=$(curl -s "https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=$DUCKDNS_TOKEN&ip=$VM_IP")
          
          echo "üì° Duck DNS API Response: $RESPONSE"
          
          if [ "$RESPONSE" = "OK" ]; then
            echo "‚úÖ Duck DNS updated successfully!"
            echo "üåê Your domain $DUCKDNS_SUBDOMAIN.duckdns.org now points to $VM_IP"
            echo ""
            echo "üïí DNS propagation typically takes 1-5 minutes"
            echo "üîç You can check with: nslookup $DUCKDNS_SUBDOMAIN.duckdns.org"
          elif [ "$RESPONSE" = "KO" ]; then
            echo "‚ùå Duck DNS update failed with 'KO' response"
            echo ""
            echo "üîç Common causes:"
            echo "1. ‚ùå Invalid Duck DNS token"
            echo "2. ‚ùå Subdomain doesn't exist or not owned by this token"
            echo "3. ‚ùå Subdomain name format issue"
            echo ""
            echo "üõ†Ô∏è Troubleshooting steps:"
            echo "1. Visit https://www.duckdns.org/ and log in"
            echo "2. Verify your token matches the one in GitHub Secrets"
            echo "3. Check that subdomain '$DUCKDNS_SUBDOMAIN' exists in your account"
            echo "4. If subdomain doesn't exist, create it first"
            echo "5. Test manually: curl 'https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=YOUR_TOKEN&ip=$VM_IP'"
            echo ""
            echo "üìã Current values:"
            echo "- Subdomain: $DUCKDNS_SUBDOMAIN"
            echo "- Full domain: $DUCKDNS_SUBDOMAIN.duckdns.org"
            echo "- Target IP: $VM_IP"
            echo "- Token (first 8 chars): ${DUCKDNS_TOKEN:0:8}..."
            exit 1
          else
            echo "‚ùå Unexpected Duck DNS response: $RESPONSE"
            echo "Please check Duck DNS service status or try again later"
            exit 1
          fi

      # Store infrastructure details (alternative method due to permissions)
      - name: üíæ Store Infrastructure Details
        env:
          VM_NAME: ${{ steps.extract_outputs.outputs.vm_name }}
          VM_ZONE: ${{ steps.extract_outputs.outputs.vm_zone }}
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
          SITE_URL: ${{ steps.extract_outputs.outputs.site_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üíæ Storing infrastructure details..."
          
          # Create a deployment info file that other workflows can use
          mkdir -p .deployment-info
          cat > .deployment-info/infrastructure.json << EOF
          {
            "vm_name": "$VM_NAME",
            "vm_zone": "$VM_ZONE", 
            "vm_external_ip": "$VM_IP",
            "site_url": "$SITE_URL",
            "environment": "${{ env.ENVIRONMENT }}",
            "project_id": "${{ env.GCP_PROJECT_ID }}",
            "domain_name": "${{ env.DOMAIN_NAME }}",
            "region": "${{ github.event.inputs.region }}",
            "machine_type": "${{ github.event.inputs.machine_type }}",
            "use_duckdns": "${{ env.USE_DUCKDNS }}",
            "duckdns_subdomain": "${{ env.DUCKDNS_SUBDOMAIN }}",
            "provisioned_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_number": "${{ github.run_number }}"
          }
          EOF
          
          # Create simplified environment file for easy sourcing
          cat > .deployment-info/environment.env << EOF
          # Infrastructure Details - Generated $(date)
          export GCP_VM_INSTANCE="$VM_NAME"
          export GCP_VM_ZONE="$VM_ZONE"
          export GCP_VM_EXTERNAL_IP="$VM_IP"
          export SITE_URL="$SITE_URL"
          export ENVIRONMENT="${{ env.ENVIRONMENT }}"
          export GCP_PROJECT_ID="${{ env.GCP_PROJECT_ID }}"
          export DOMAIN_NAME="${{ env.DOMAIN_NAME }}"
          export USE_DUCKDNS="${{ env.USE_DUCKDNS }}"
          export DUCKDNS_SUBDOMAIN="${{ env.DUCKDNS_SUBDOMAIN }}"
          EOF
          
          # Try to set GitHub Variables (with error handling)
          echo "üîê Attempting to store as GitHub Variables..."
          set +e  # Don't exit on error
          
          # Try individual variable setting with better error handling
          for var_name in "GCP_VM_INSTANCE:$VM_NAME" "GCP_VM_ZONE:$VM_ZONE" "GCP_VM_EXTERNAL_IP:$VM_IP" "SITE_URL:$SITE_URL" "ENVIRONMENT:${{ env.ENVIRONMENT }}"; do
            name="${var_name%%:*}"
            value="${var_name#*:}"
            
            if gh variable set "$name" --body "$value" --repo ${{ github.repository }} 2>/dev/null; then
              echo "‚úÖ Set variable: $name"
            else
              echo "‚ö†Ô∏è Could not set variable: $name (permissions issue)"
            fi
          done
          
          # Duck DNS variables
          if [ "${{ env.USE_DUCKDNS }}" = "true" ]; then
            if gh variable set "USE_DUCKDNS" --body "true" --repo ${{ github.repository }} 2>/dev/null; then
              echo "‚úÖ Set variable: USE_DUCKDNS"
            else
              echo "‚ö†Ô∏è Could not set variable: USE_DUCKDNS"
            fi
            
            if gh variable set "DUCKDNS_SUBDOMAIN" --body "${{ env.DUCKDNS_SUBDOMAIN }}" --repo ${{ github.repository }} 2>/dev/null; then
              echo "‚úÖ Set variable: DUCKDNS_SUBDOMAIN"  
            else
              echo "‚ö†Ô∏è Could not set variable: DUCKDNS_SUBDOMAIN"
            fi
          fi
          
          set -e  # Re-enable exit on error
          
          echo ""
          echo "‚úÖ Infrastructure details stored in deployment files!"
          echo ""
          echo "üìã Stored Information:"
          echo "- VM Instance: $VM_NAME"
          echo "- VM Zone: $VM_ZONE"
          echo "- External IP: $VM_IP"
          echo "- Site URL: $SITE_URL"
          echo "- Environment: ${{ env.ENVIRONMENT }}"
          echo ""
          echo "üìÅ Files created:"
          echo "- .deployment-info/infrastructure.json (detailed JSON)"
          echo "- .deployment-info/environment.env (shell variables)"
          echo ""
          echo "üîç DNS Configuration:"
          echo "Configure your DNS provider with:"
          echo "- Type: A Record"
          echo "- Name: ${{ env.DOMAIN_NAME }}"
          echo "- Value: $VM_IP"
          echo "- TTL: 300 (5 minutes)"
          echo ""
          echo "üí° Other workflows can read these files to get infrastructure details"

      # Commit deployment info files to repository  
      - name: üíæ Commit Infrastructure Info
        env:
          VM_NAME: ${{ steps.extract_outputs.outputs.vm_name }}
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
        run: |
          # Add deployment info to git (but ignore in .gitignore for security)
          echo "üìù Managing deployment information..."
          
          # Ensure .gitignore exists and has proper entries
          if ! grep -q ".deployment-info/" .gitignore 2>/dev/null; then
            echo "" >> .gitignore
            echo "# Deployment information (may contain sensitive data)" >> .gitignore
            echo ".deployment-info/" >> .gitignore
            echo "‚úÖ Added .deployment-info/ to .gitignore"
          fi
          
          # Configure git (in case not set)
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Only commit gitignore changes, not the sensitive deployment files
          if git diff --quiet .gitignore; then
            echo "üìã .gitignore already up to date"
          else
            git add .gitignore
            git commit -m "chore: add deployment-info to gitignore

            - Protect sensitive infrastructure information
            - Added by infrastructure provisioning workflow" || echo "‚ö†Ô∏è Commit failed (may already exist)"
            echo "‚úÖ Updated .gitignore with deployment info exclusion"
          fi
          
          echo ""
          echo "üîí Security Note:"
          echo "- Deployment files contain sensitive information"
          echo "- Files are created locally but NOT committed to repository"
          echo "- Other workflows in the same run can access these files"
          echo "- Files are automatically cleaned up after workflow completion"

      # Verify DNS propagation (if Duck DNS is used)
      - name: üîç Verify DNS Propagation
        if: env.USE_DUCKDNS == 'true'
        env:
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
        run: |
          echo "üîç Checking DNS propagation for $DUCKDNS_SUBDOMAIN.duckdns.org..."
          
          # Wait a bit for initial propagation
          sleep 10
          
          # Try to resolve the domain
          for i in {1..6}; do
            RESOLVED_IP=$(nslookup $DUCKDNS_SUBDOMAIN.duckdns.org 2>/dev/null | grep "Address:" | tail -1 | awk '{print $2}')
            
            if [ "$RESOLVED_IP" = "$VM_IP" ]; then
              echo "‚úÖ DNS propagation successful!"
              echo "üåê $DUCKDNS_SUBDOMAIN.duckdns.org resolves to $VM_IP"
              break
            else
              echo "‚è≥ DNS still propagating... (attempt $i/6)"
              if [ $i -lt 6 ]; then
                sleep 30
              else
                echo "‚ö†Ô∏è DNS propagation taking longer than expected"
                echo "üìã Expected: $VM_IP"
                echo "üìã Got: $RESOLVED_IP"
                echo "üïí This is normal and should resolve within 5-10 minutes"
              fi
            fi
          done

      # Store SSH private key as secret for next workflows
      - name: üîê Store SSH Key
        run: |
          echo "üíæ SSH private key stored for subsequent workflows"
          # In real scenario, you'd store this in a secure way
          # For now, we'll use gcloud ssh which handles keys automatically

      # Summary
      - name: üìä Infrastructure Summary
        env:
          VM_NAME: ${{ steps.extract_outputs.outputs.vm_name }}
          VM_ZONE: ${{ steps.extract_outputs.outputs.vm_zone }}
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
          SITE_URL: ${{ steps.extract_outputs.outputs.site_url }}
        run: |
          echo "## üèóÔ∏è Infrastructure Provisioning Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Resources Created:" >> $GITHUB_STEP_SUMMARY
          echo "- **VM Instance**: \`$VM_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Zone**: \`$VM_ZONE\`" >> $GITHUB_STEP_SUMMARY
          echo "- **External IP**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Site URL**: $SITE_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: \`${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.USE_DUCKDNS }}" = "true" ]; then
            echo "### ü¶Ü Duck DNS Configuration:" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Duck DNS automatically configured!**" >> $GITHUB_STEP_SUMMARY
            echo "- **Domain**: \`${{ env.DUCKDNS_SUBDOMAIN }}.duckdns.org\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Points to**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: Active (propagation takes 1-5 minutes)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üîç **Verify DNS**: \`nslookup ${{ env.DUCKDNS_SUBDOMAIN }}.duckdns.org\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### üåê DNS Configuration Required:" >> $GITHUB_STEP_SUMMARY
            echo "Configure your DNS provider with an **A Record**:" >> $GITHUB_STEP_SUMMARY
            echo "- **Type**: A Record" >> $GITHUB_STEP_SUMMARY
            echo "- **Name**: \`${{ env.DOMAIN_NAME }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Value**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
            echo "- **TTL**: 300 (5 minutes)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üí° **Tip**: Consider using Duck DNS for easier setup!" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Stored GitHub Variables:" >> $GITHUB_STEP_SUMMARY
          echo "- \`GCP_VM_INSTANCE\`: $VM_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- \`GCP_VM_ZONE\`: $VM_ZONE" >> $GITHUB_STEP_SUMMARY  
          echo "- \`GCP_VM_EXTERNAL_IP\`: $VM_IP" >> $GITHUB_STEP_SUMMARY
          echo "- \`SITE_URL\`: $SITE_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üéØ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. **Configure DNS** with your domain provider" >> $GITHUB_STEP_SUMMARY
          echo "2. Wait 5-10 minutes for DNS propagation" >> $GITHUB_STEP_SUMMARY
          echo "3. Run **Install Packages** workflow" >> $GITHUB_STEP_SUMMARY
          echo "4. Run **Configure Environment** workflow" >> $GITHUB_STEP_SUMMARY
          echo "5. Run **Deploy Plugin** workflow" >> $GITHUB_STEP_SUMMARY