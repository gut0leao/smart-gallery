name: "2. Provision infrastructure ðŸ—ï¸"

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: 'GCP Project ID'
        required: true
        type: string
      domain_name:
        description: 'Domain name (e.g., smartgallery.exemplo.com or mysite.duckdns.org)'
        required: true
        type: string
      use_duckdns:
        description: 'Use Duck DNS for automatic DNS management'
        required: false
        default: false
        type: boolean
      duckdns_subdomain:
        description: 'Duck DNS subdomain (only the part before .duckdns.org)'
        required: false
        type: string
      environment:
        description: 'Environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      region:
        description: 'GCP Region'
        required: false
        default: 'us-central1'
        type: string
      machine_type:
        description: 'VM Machine Type'
        required: false
        default: 'e2-micro'
        type: choice
        options:
          - e2-micro
          - e2-small
          - e2-medium

env:
  TF_VERSION: '1.6.0'
  GCP_PROJECT_ID: ${{ github.event.inputs.project_id }}
  DOMAIN_NAME: ${{ github.event.inputs.domain_name }}
  ENVIRONMENT: ${{ github.event.inputs.environment }}
  USE_DUCKDNS: ${{ github.event.inputs.use_duckdns }}
  DUCKDNS_SUBDOMAIN: ${{ github.event.inputs.duckdns_subdomain }}

jobs:
  provision:
    name: ðŸ—ï¸ Terraform Provision
    runs-on: ubuntu-latest
    
    outputs:
      vm_name: ${{ steps.extract_outputs.outputs.vm_name }}
      vm_zone: ${{ steps.extract_outputs.outputs.vm_zone }}
      vm_external_ip: ${{ steps.extract_outputs.outputs.vm_external_ip }}
      site_url: ${{ steps.extract_outputs.outputs.site_url }}
    
    steps:
      # Checkout repository
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      # Setup Terraform
      - name: ðŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      # Authenticate to GCP
      - name: ðŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      # Setup Google Cloud SDK
      - name: â˜ï¸ Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      # Generate or reuse SSH key for VM access
      - name: ðŸ”‘ Setup SSH Key for VM Access
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ”‘ Setting up SSH key for VM access..."
          
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Check if we already have an SSH key in Secrets
          if [ -n "${{ secrets.VM_SSH_PRIVATE_KEY }}" ]; then
            echo "âœ… Using existing SSH key from Secrets"
            echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            
            # Generate public key from private key
            ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
            chmod 644 ~/.ssh/id_rsa.pub
          else
            echo "ðŸ†• Generating new SSH key for Smart Gallery VM access..."
            
            # Generate new SSH key
            ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N "" -C "smart-gallery-vm-$(date +%Y%m%d)"
            
            # Store private key as GitHub Secret for future workflows
            echo "ðŸ” Storing SSH private key as GitHub Secret..."
            
            # Determine which token to use
            if [ -n "${{ secrets.GH_PAT }}" ]; then
              GITHUB_AUTH_TOKEN="${{ secrets.GH_PAT }}"
              TOKEN_TYPE="Personal Access Token"
            else
              GITHUB_AUTH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
              TOKEN_TYPE="Default GITHUB_TOKEN"
            fi
            
            # Store private key as Secret via GitHub CLI (more reliable)
            echo "ðŸ” Storing SSH private key as GitHub Secret..."
            
            # Use GitHub CLI to store the secret (handles encryption automatically)
            if command -v gh >/dev/null 2>&1; then
              # Store private key content as secret (read from stdin)
              cat ~/.ssh/id_rsa | gh secret set VM_SSH_PRIVATE_KEY
              echo "âœ… SSH key stored as VM_SSH_PRIVATE_KEY secret via GitHub CLI"
            else
              echo "âš ï¸ GitHub CLI not available, storing key for this session only"
              echo "ðŸ’¡ The key will be available in VM metadata for this provisioning"
              echo "ðŸ’¡ For persistent storage, manually add the private key to Secrets as VM_SSH_PRIVATE_KEY"
            fi
            
            echo "âœ… SSH key generated and ready for use"
            echo "ðŸ’¡ All subsequent workflows will use this key automatically"
          fi
          
          # Store public key for Terraform
          echo "SSH_PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)" >> $GITHUB_ENV
          echo "âœ… SSH key ready for VM provisioning"

      # Terraform Init
      - name: ðŸ—ï¸ Terraform Init
        working-directory: terraform
        run: |
          terraform init -upgrade
          echo "âœ… Terraform initialized"

      # Check for existing resources and import if needed
      - name: ðŸ” Check Existing Resources & Import
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
          TF_VAR_zone: ${{ github.event.inputs.region }}-a
        run: |
          echo "ðŸ” Checking for existing resources and importing if needed..."
          
          # Set environment variables for resource names
          NAME_PREFIX="smart-gallery-${{ env.ENVIRONMENT }}"
          ZONE="${{ github.event.inputs.region }}-a"
          
          # Enhanced function to safely import resources with better error handling
          safe_import() {
            local resource_type="$1"
            local resource_name="$2"
            local gcp_resource_id="$3"
            local gcp_command="$4"
            local resource_display_name="$5"
            
            echo "ðŸ” Checking $resource_display_name..."
            
            # First check if resource exists in Terraform state
            if terraform state show "$resource_type.$resource_name" >/dev/null 2>&1; then
              echo "âœ… $resource_display_name already managed by Terraform"
              
              # Verify the resource still exists in GCP
              if eval "$gcp_command" >/dev/null 2>&1; then
                echo "âœ… $resource_display_name confirmed in GCP"
              else
                echo "âš ï¸ $resource_display_name in Terraform state but not in GCP - will be recreated"
                terraform state rm "$resource_type.$resource_name" || true
              fi
              return 0
            fi
            
            # Check if resource exists in GCP
            if eval "$gcp_command" >/dev/null 2>&1; then
              echo "ðŸ“¥ Found existing $resource_display_name in GCP - importing..."
              
              # Attempt to import the resource
              if terraform import "$resource_type.$resource_name" "$gcp_resource_id" 2>/dev/null; then
                echo "âœ… Successfully imported $resource_display_name"
              else
                echo "âš ï¸ Import failed for $resource_display_name"
                echo "ðŸ”„ This usually means resource configuration doesn't match"
                echo "ðŸ“‹ Resource will be recreated with correct configuration"
              fi
            else
              echo "âž• $resource_display_name will be created (not found in GCP)"
            fi
          }
          
          # Function to check VM status and avoid unnecessary recreation
          check_vm_status() {
            local vm_name="$1"
            local zone="$2"
            
            if gcloud compute instances describe "$vm_name" --zone="$zone" --format="value(status)" 2>/dev/null; then
              VM_STATUS=$(gcloud compute instances describe "$vm_name" --zone="$zone" --format="value(status)" 2>/dev/null)
              VM_MACHINE_TYPE=$(gcloud compute instances describe "$vm_name" --zone="$zone" --format="value(machineType)" 2>/dev/null | sed 's|.*/||')
              VM_DISK_SIZE=$(gcloud compute instances describe "$vm_name" --zone="$zone" --format="value(disks[0].diskSizeGb)" 2>/dev/null)
              
              echo "ðŸ“Š VM Status Report:"
              echo "  â€¢ Status: $VM_STATUS"
              echo "  â€¢ Machine Type: $VM_MACHINE_TYPE"
              echo "  â€¢ Disk Size: ${VM_DISK_SIZE}GB"
              echo "  â€¢ Requested Type: ${{ github.event.inputs.machine_type }}"
              
              # Check if VM configuration matches requirements
              if [ "$VM_MACHINE_TYPE" = "${{ github.event.inputs.machine_type }}" ]; then
                echo "âœ… VM configuration matches requirements"
                return 0
              else
                echo "âš ï¸ VM machine type differs from requested"
                echo "ðŸ”„ VM will be updated to match configuration"
                return 1
              fi
            else
              echo "âž• VM not found - will be created"
              return 2
            fi
          }
          
          # Import network resources
          echo "ðŸŒ Checking Network Resources..."
          safe_import "google_compute_network" "smart_gallery_network" \
            "projects/${{ env.GCP_PROJECT_ID }}/global/networks/$NAME_PREFIX-network" \
            "gcloud compute networks describe '$NAME_PREFIX-network' --project='${{ env.GCP_PROJECT_ID }}' --quiet" \
            "VPC Network"
          
          safe_import "google_compute_subnetwork" "smart_gallery_subnet" \
            "projects/${{ env.GCP_PROJECT_ID }}/regions/${{ github.event.inputs.region }}/subnetworks/$NAME_PREFIX-subnet" \
            "gcloud compute networks subnets describe '$NAME_PREFIX-subnet' --region='${{ github.event.inputs.region }}' --project='${{ env.GCP_PROJECT_ID }}' --quiet" \
            "Subnet"
          
          # Import static IP
          echo "ðŸŒ Checking Static IP..."
          safe_import "google_compute_address" "smart_gallery_ip" \
            "projects/${{ env.GCP_PROJECT_ID }}/regions/${{ github.event.inputs.region }}/addresses/$NAME_PREFIX-ip" \
            "gcloud compute addresses describe '$NAME_PREFIX-ip' --region='${{ github.event.inputs.region }}' --project='${{ env.GCP_PROJECT_ID }}' --quiet" \
            "Static IP"
          
          # Enhanced VM check and import
          echo "ðŸ–¥ï¸ Checking VM Instance..."
          if check_vm_status "$NAME_PREFIX-vm" "$ZONE"; then
            # VM exists and configuration matches - try to import
            if ! terraform state show "google_compute_instance.smart_gallery_vm" >/dev/null 2>&1; then
              echo "ðŸ“¥ Importing existing VM..."
              
              if terraform import "google_compute_instance.smart_gallery_vm" \
                "projects/${{ env.GCP_PROJECT_ID }}/zones/$ZONE/instances/$NAME_PREFIX-vm" 2>/dev/null; then
                echo "âœ… VM imported successfully"
              else
                echo "âš ï¸ VM import failed - configuration may differ"
                echo "ðŸ”„ VM will be managed but may require updates"
              fi
            else
              echo "âœ… VM already in Terraform state"
            fi
          fi
          
          # Import firewall rules
          echo "ðŸ”¥ Checking Firewall Rules..."
          declare -A fw_rules=(
            ["ssh"]="smart_gallery_ssh"
            ["http"]="smart_gallery_http"
            ["https"]="smart_gallery_https"
            ["icmp"]="smart_gallery_icmp"
          )
          
          for fw_type in "${!fw_rules[@]}"; do
            tf_resource_name="${fw_rules[$fw_type]}"
            gcp_rule_name="$NAME_PREFIX-allow-$fw_type"
            
            safe_import "google_compute_firewall" "$tf_resource_name" \
              "projects/${{ env.GCP_PROJECT_ID }}/global/firewalls/$gcp_rule_name" \
              "gcloud compute firewall-rules describe '$gcp_rule_name' --project='${{ env.GCP_PROJECT_ID }}' --quiet" \
              "Firewall Rule ($fw_type)"
          done
          
          echo "âœ… Resource import process completed"
          
          # Show current state summary
          echo ""
          echo "ðŸ“‹ Current Terraform State Summary:"
          terraform state list 2>/dev/null | sort || echo "No resources in state yet"

      # Terraform Plan with detailed analysis
      - name: ðŸ“‹ Terraform Plan & Analysis
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
          TF_VAR_zone: ${{ github.event.inputs.region }}-a
        run: |
          echo "ðŸ“‹ Creating Terraform plan with detailed analysis..."
          
          # Create plan with detailed output (don't exit on code 2)
          set +e  # Disable exit on error temporarily
          PLAN_OUTPUT=$(terraform plan -out=tfplan -detailed-exitcode 2>&1)
          PLAN_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Save plan output for analysis
          echo "$PLAN_OUTPUT" > plan_output.txt
          
          # Analyze the plan
          echo "ðŸ” Analyzing Terraform plan..."
          
          # Check for destructive operations
          if echo "$PLAN_OUTPUT" | grep -q "must be replaced\|will be destroyed"; then
            echo "âš ï¸ DESTRUCTIVE OPERATIONS DETECTED!"
            echo ""
            echo "ðŸ“Š Resources that will be DESTROYED/REPLACED:"
            echo "$PLAN_OUTPUT" | grep -A 2 -B 2 "must be replaced\|will be destroyed" || true
            echo ""
            echo "ðŸ¤” Common reasons for resource replacement:"
            echo "  â€¢ VM machine type change"
            echo "  â€¢ Network configuration change"
            echo "  â€¢ Disk configuration change"
            echo "  â€¢ Zone change"
            echo ""
            
            # Check specifically for VM replacement
            if echo "$PLAN_OUTPUT" | grep -q "google_compute_instance.*must be replaced"; then
              echo "ï¿½ï¸ VM REPLACEMENT DETECTED!"
              echo ""
              echo "ðŸ’¡ To avoid VM replacement, ensure:"
              echo "  â€¢ Machine type matches existing VM"
              echo "  â€¢ Zone matches existing VM location"
              echo "  â€¢ Network configuration is consistent"
              echo ""
              echo "ðŸ› ï¸ You can modify the VM after creation if needed:"
              echo "  â€¢ Stop VM: gcloud compute instances stop VM_NAME --zone=ZONE"
              echo "  â€¢ Change type: gcloud compute instances set-machine-type VM_NAME --machine-type=NEW_TYPE --zone=ZONE"
              echo "  â€¢ Start VM: gcloud compute instances start VM_NAME --zone=ZONE"
            fi
          fi
          
          # Check for creation operations
          if echo "$PLAN_OUTPUT" | grep -q "will be created"; then
            echo "âž• NEW RESOURCES TO CREATE:"
            echo "$PLAN_OUTPUT" | grep -A 1 "will be created" | grep "^  #" || true
            echo ""
          fi
          
          # Check for updates
          if echo "$PLAN_OUTPUT" | grep -q "will be updated in-place"; then
            echo "ðŸ”„ RESOURCES TO UPDATE IN-PLACE:"
            echo "$PLAN_OUTPUT" | grep -A 1 "will be updated in-place" | grep "^  #" || true
            echo ""
          fi
          
          # Handle plan exit codes
          case $PLAN_EXIT_CODE in
            0)
              echo "âœ… No changes needed - infrastructure is up to date!"
              echo "PLAN_HAS_CHANGES=false" >> $GITHUB_ENV
              ;;
            1)
              echo "âŒ Terraform plan failed!"
              echo ""
              echo "ðŸ“‹ Plan output:"
              echo "----------------------------------------"
              cat plan_output.txt
              echo "----------------------------------------"
              echo ""
              echo "ðŸ” This usually indicates:"
              echo "â€¢ Syntax errors in Terraform configuration"
              echo "â€¢ Missing required variables"
              echo "â€¢ Authentication or permission issues"
              echo "â€¢ Invalid resource configurations"
              exit 1
              ;;
            2)
              echo "ðŸ“ Changes detected - plan created successfully"
              echo "PLAN_HAS_CHANGES=true" >> $GITHUB_ENV
              
              # Count operations with safer parsing
              CREATE_COUNT=$(echo "$PLAN_OUTPUT" | grep -c "will be created" 2>/dev/null || echo "0")
              UPDATE_COUNT=$(echo "$PLAN_OUTPUT" | grep -c "will be updated in-place" 2>/dev/null || echo "0")
              REPLACE_COUNT=$(echo "$PLAN_OUTPUT" | grep -c "must be replaced" 2>/dev/null || echo "0")
              DESTROY_COUNT=$(echo "$PLAN_OUTPUT" | grep -c "will be destroyed" 2>/dev/null || echo "0")
              
              # Validate counts are numbers
              CREATE_COUNT=${CREATE_COUNT//[^0-9]/}
              UPDATE_COUNT=${UPDATE_COUNT//[^0-9]/}
              REPLACE_COUNT=${REPLACE_COUNT//[^0-9]/}
              DESTROY_COUNT=${DESTROY_COUNT//[^0-9]/}
              
              # Set defaults if empty
              CREATE_COUNT=${CREATE_COUNT:-0}
              UPDATE_COUNT=${UPDATE_COUNT:-0}
              REPLACE_COUNT=${REPLACE_COUNT:-0}
              DESTROY_COUNT=${DESTROY_COUNT:-0}
              
              echo ""
              echo "ðŸ“Š PLAN SUMMARY:"
              echo "  â€¢ Resources to create: $CREATE_COUNT"
              echo "  â€¢ Resources to update: $UPDATE_COUNT"
              echo "  â€¢ Resources to replace: $REPLACE_COUNT"
              echo "  â€¢ Resources to destroy: $DESTROY_COUNT"
              
              # Store counts for later use with safe values
              {
                echo "CREATE_COUNT=$CREATE_COUNT"
                echo "UPDATE_COUNT=$UPDATE_COUNT"
                echo "REPLACE_COUNT=$REPLACE_COUNT"
                echo "DESTROY_COUNT=$DESTROY_COUNT"
              } >> $GITHUB_ENV
              ;;
          esac
          
          echo ""
          echo "âœ… Terraform plan analysis completed"

      # Terraform Apply with safeguards
      - name: ðŸš€ Terraform Apply
        id: terraform
        if: env.PLAN_HAS_CHANGES == 'true'
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
          TF_VAR_zone: ${{ github.event.inputs.region }}-a
        run: |
          echo "ðŸš€ Applying Terraform configuration..."
          
          # Show what will be applied with safe variable handling
          REPLACE_COUNT=${REPLACE_COUNT:-0}
          DESTROY_COUNT=${DESTROY_COUNT:-0}
          
          if [ "$REPLACE_COUNT" -gt 0 ] || [ "$DESTROY_COUNT" -gt 0 ]; then
            TOTAL_DESTRUCTIVE=$((REPLACE_COUNT + DESTROY_COUNT))
            echo "âš ï¸  DESTRUCTIVE OPERATIONS WARNING!"
            echo "This will destroy/replace $TOTAL_DESTRUCTIVE resources"
            echo ""
            echo "ðŸ’¾ Before proceeding, consider backing up important data:"
            echo "  â€¢ Database content"  
            echo "  â€¢ WordPress files"
            echo "  â€¢ SSL certificates"
            echo "  â€¢ Configuration files"
            echo ""
          fi
          
          # Apply the plan
          if [ -f tfplan ]; then
            echo "ðŸ“‹ Applying planned changes..."
            terraform apply -auto-approve tfplan
          else
            echo "âš ï¸ No plan file found, this shouldn't happen..."
            echo "Running direct apply as fallback..."
            terraform apply -auto-approve
          fi
          
          echo "âœ… Terraform apply completed!"
      
      # Handle case where no changes needed
      - name: â„¹ï¸ No Changes Needed  
        if: env.PLAN_HAS_CHANGES == 'false'
        working-directory: terraform
        run: |
          echo "âœ… Infrastructure is already up to date!"
          echo "ðŸ“‹ Current resources are matching the desired configuration"
          
          # Still extract outputs for consistency
          echo "ðŸ“¤ Extracting current infrastructure information..."
          
      # Extract outputs (works for both apply and no-changes scenarios)  
      - name: ðŸ“¤ Extract Infrastructure Information
        id: extract_outputs
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
          TF_VAR_zone: ${{ github.event.inputs.region }}-a
        run: |
          echo "ðŸ“¤ Extracting infrastructure information..."
          
          NAME_PREFIX="smart-gallery-${{ env.ENVIRONMENT }}"
          ZONE="${{ github.event.inputs.region }}-a"
          
          # Function to get outputs with intelligent fallback
          get_infrastructure_info() {
            echo "ðŸ” Gathering infrastructure details..."
            
            # Try Terraform outputs first
            if terraform output vm_name >/dev/null 2>&1; then
              VM_NAME=$(terraform output -raw vm_name)
              echo "âœ… VM name from Terraform: $VM_NAME"
            else
              VM_NAME="$NAME_PREFIX-vm"
              echo "ðŸ“‹ VM name constructed: $VM_NAME"
            fi
            
            if terraform output vm_zone >/dev/null 2>&1; then
              VM_ZONE=$(terraform output -raw vm_zone)
              echo "âœ… VM zone from Terraform: $VM_ZONE"
            else
              VM_ZONE="$ZONE"
              echo "ðŸ“‹ VM zone constructed: $VM_ZONE"
            fi
            
            # For IP, try multiple methods
            VM_IP=""
            if terraform output vm_external_ip >/dev/null 2>&1; then
              VM_IP=$(terraform output -raw vm_external_ip)
              echo "âœ… VM IP from Terraform: $VM_IP"
            else
              # Try to get IP from GCP directly
              echo "ðŸ” Querying VM IP from GCP..."
              VM_IP=$(gcloud compute instances describe "$VM_NAME" \
                --zone="$VM_ZONE" \
                --format="get(networkInterfaces[0].accessConfigs[0].natIP)" 2>/dev/null || echo "")
              
              if [ -n "$VM_IP" ]; then
                echo "âœ… VM IP from GCP: $VM_IP"
              else
                # Try static IP if VM query failed
                echo "ðŸ” Trying to get static IP..."
                VM_IP=$(gcloud compute addresses describe "$NAME_PREFIX-ip" \
                  --region="${{ github.event.inputs.region }}" \
                  --format="get(address)" 2>/dev/null || echo "")
                
                if [ -n "$VM_IP" ]; then
                  echo "âœ… Static IP found: $VM_IP"
                else
                  echo "âš ï¸ Could not determine VM IP"
                  VM_IP="unknown"
                fi
              fi
            fi
            
            # Site URL
            if terraform output site_url >/dev/null 2>&1; then
              SITE_URL=$(terraform output -raw site_url)
              echo "âœ… Site URL from Terraform: $SITE_URL"
            else
              SITE_URL="https://${{ env.DOMAIN_NAME }}"
              echo "ðŸ“‹ Site URL constructed: $SITE_URL"
            fi
            
            # Verify VM actually exists and is accessible
            echo "ðŸ” Verifying VM status..."
            if gcloud compute instances describe "$VM_NAME" --zone="$VM_ZONE" --format="value(status)" 2>/dev/null; then
              VM_STATUS=$(gcloud compute instances describe "$VM_NAME" --zone="$VM_ZONE" --format="value(status)" 2>/dev/null)
              echo "âœ… VM Status: $VM_STATUS"
            else
              echo "âš ï¸ VM not found or not accessible"
              VM_STATUS="unknown"
            fi
            
            # Output to GitHub Actions
            echo "vm_name=$VM_NAME" >> $GITHUB_OUTPUT
            echo "vm_zone=$VM_ZONE" >> $GITHUB_OUTPUT  
            echo "vm_external_ip=$VM_IP" >> $GITHUB_OUTPUT
            echo "site_url=$SITE_URL" >> $GITHUB_OUTPUT
            
            # Also set as environment variables for later steps
            echo "VM_NAME=$VM_NAME" >> $GITHUB_ENV
            echo "VM_ZONE=$VM_ZONE" >> $GITHUB_ENV
            echo "VM_EXTERNAL_IP=$VM_IP" >> $GITHUB_ENV
            echo "SITE_URL=$SITE_URL" >> $GITHUB_ENV
            
            echo ""
            echo "ðŸ“Š Infrastructure Summary:"
            echo "  â€¢ VM Name: $VM_NAME"
            echo "  â€¢ VM Zone: $VM_ZONE"
            echo "  â€¢ VM Status: $VM_STATUS"
            echo "  â€¢ External IP: $VM_IP"
            echo "  â€¢ Site URL: $SITE_URL"
            echo ""
          }
          
          # Execute the function
          get_infrastructure_info
          
          if [ "${{ env.PLAN_HAS_CHANGES }}" = "true" ]; then
            echo "âœ… Infrastructure changes applied successfully!"
          else
            echo "âœ… Infrastructure information extracted from existing resources!"
          fi

      # Wait for VM to be ready
      - name: â³ Wait for VM Startup
        env:
          VM_NAME: ${{ steps.extract_outputs.outputs.vm_name }}
          VM_ZONE: ${{ steps.extract_outputs.outputs.vm_zone }}
        run: |
          echo "â³ Waiting for VM to be ready for SSH connections..."
          
          # First, wait for VM to be accessible via SSH (basic connectivity)
          echo "ðŸ” Testing SSH connectivity..."
          SSH_READY=false
          for i in {1..12}; do
            if gcloud compute ssh $VM_NAME \
              --zone=$VM_ZONE \
              --command="echo 'SSH Ready'" \
              --quiet 2>/dev/null; then
              echo "âœ… SSH connection established (attempt $i/12)"
              SSH_READY=true
              break
            fi
            echo "â³ Waiting for SSH... (attempt $i/12)"
            sleep 10
          done
          
          if [ "$SSH_READY" = "false" ]; then
            echo "âŒ Could not establish SSH connection after 2 minutes"
            echo "ðŸ” VM may still be booting or SSH service not ready"
            exit 1
          fi
          
          # Now check for startup script completion (with shorter timeout)
          echo ""
          echo "ðŸ” Checking startup script completion..."
          STARTUP_COMPLETED=false
          for i in {1..6}; do
            if gcloud compute ssh $VM_NAME \
              --zone=$VM_ZONE \
              --command="test -f /var/log/startup-completed" \
              --quiet 2>/dev/null; then
              echo "âœ… Startup script completed successfully!"
              STARTUP_COMPLETED=true
              break
            fi
            echo "â³ Waiting for startup script... (attempt $i/6)"
            sleep 10
          done
          
          if [ "$STARTUP_COMPLETED" = "false" ]; then
            echo "âš ï¸ Startup script completion marker not found after 1 minute"
            echo "ðŸ“‹ This is usually OK - the script may still be running in background"
            echo "ðŸ” Checking startup script log..."
            
            # Try to get last lines of startup log
            if gcloud compute ssh $VM_NAME \
              --zone=$VM_ZONE \
              --command="tail -15 /var/log/startup-script.log 2>/dev/null || echo 'Log not available yet'" \
              --quiet 2>/dev/null; then
              echo ""
              echo "ðŸ’¡ Startup script is running - package installation will wait if needed"
            else
              echo "âš ï¸ Could not check startup log, but VM is accessible"
            fi
            
            # Don't fail - just warn
            echo ""
            echo "âœ… Proceeding with VM accessible (startup script may complete in background)"
          fi
          
          echo ""
          echo "âœ… VM is ready for next workflow steps!"

      # Configure Duck DNS automatically (if enabled)
      - name: ðŸ¦† Configure Duck DNS
        if: env.USE_DUCKDNS == 'true'
        env:
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
          DUCKDNS_TOKEN: ${{ secrets.DUCKDNS_TOKEN }}
        run: |
          if [ -z "$DUCKDNS_TOKEN" ]; then
            echo "âŒ DUCKDNS_TOKEN secret not found!"
            echo "Please add your Duck DNS token as a repository secret named DUCKDNS_TOKEN"
            echo "Get your token from: https://www.duckdns.org/"
            exit 1
          fi
          
          if [ -z "$DUCKDNS_SUBDOMAIN" ]; then
            echo "âŒ Duck DNS subdomain not provided!"
            exit 1
          fi
          
          # Validate subdomain format (no special chars, reasonable length)
          if [[ ! "$DUCKDNS_SUBDOMAIN" =~ ^[a-zA-Z0-9-]{1,63}$ ]]; then
            echo "âŒ Invalid Duck DNS subdomain format: $DUCKDNS_SUBDOMAIN"
            echo "Subdomain must contain only letters, numbers, and hyphens (1-63 chars)"
            echo "Examples: mysite, smart-gallery, test123"
            exit 1
          fi
          
          echo "ðŸ¦† Configuring Duck DNS for $DUCKDNS_SUBDOMAIN.duckdns.org..."
          echo "ðŸ“ Setting IP to: $VM_IP"
          echo "ðŸ” Using token: ${DUCKDNS_TOKEN:0:8}... (masked)"
          
          # Test Duck DNS API first
          echo "ðŸ§ª Testing Duck DNS API connectivity..."
          TEST_RESPONSE=$(curl -s -w "%{http_code}" -o /dev/null "https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=$DUCKDNS_TOKEN&txt=test")
          if [ "$TEST_RESPONSE" != "200" ]; then
            echo "âŒ Cannot reach Duck DNS API. HTTP status: $TEST_RESPONSE"
            echo "Please check your internet connection or try again later"
            exit 1
          fi
          
          # Update Duck DNS with detailed error handling
          echo "ðŸ”„ Updating Duck DNS record..."
          RESPONSE=$(curl -s "https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=$DUCKDNS_TOKEN&ip=$VM_IP")
          
          echo "ðŸ“¡ Duck DNS API Response: $RESPONSE"
          
          if [ "$RESPONSE" = "OK" ]; then
            echo "âœ… Duck DNS updated successfully!"
            echo "ðŸŒ Your domain $DUCKDNS_SUBDOMAIN.duckdns.org now points to $VM_IP"
            echo ""
            echo "ðŸ•’ DNS propagation typically takes 1-5 minutes"
            echo "ðŸ” You can check with: nslookup $DUCKDNS_SUBDOMAIN.duckdns.org"
          elif [ "$RESPONSE" = "KO" ]; then
            echo "âŒ Duck DNS update failed with 'KO' response"
            echo ""
            echo "ðŸ” Common causes:"
            echo "1. âŒ Invalid Duck DNS token"
            echo "2. âŒ Subdomain doesn't exist or not owned by this token"
            echo "3. âŒ Subdomain name format issue"
            echo ""
            echo "ðŸ› ï¸ Troubleshooting steps:"
            echo "1. Visit https://www.duckdns.org/ and log in"
            echo "2. Verify your token matches the one in GitHub Secrets"
            echo "3. Check that subdomain '$DUCKDNS_SUBDOMAIN' exists in your account"
            echo "4. If subdomain doesn't exist, create it first"
            echo "5. Test manually: curl 'https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=YOUR_TOKEN&ip=$VM_IP'"
            echo ""
            echo "ðŸ“‹ Current values:"
            echo "- Subdomain: $DUCKDNS_SUBDOMAIN"
            echo "- Full domain: $DUCKDNS_SUBDOMAIN.duckdns.org"
            echo "- Target IP: $VM_IP"
            echo "- Token (first 8 chars): ${DUCKDNS_TOKEN:0:8}..."
            exit 1
          else
            echo "âŒ Unexpected Duck DNS response: $RESPONSE"
            echo "Please check Duck DNS service status or try again later"
            exit 1
          fi

      # Infrastructure details stored in GitHub Variables only (no files created)
      - name: âœ… Infrastructure Ready - Variables Updated
        env:
          VM_NAME: ${{ steps.extract_outputs.outputs.vm_name }}
          VM_ZONE: ${{ steps.extract_outputs.outputs.vm_zone }}
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
          SITE_URL: ${{ steps.extract_outputs.outputs.site_url }}
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          echo "âœ… Infrastructure provisioning completed successfully!"
          echo ""
          echo "ðŸ“Š All infrastructure information stored in GitHub Variables:"
          echo "- GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID }} âœ…"
          echo "- GCP_VM_INSTANCE: $VM_NAME âœ…"
          echo "- GCP_VM_ZONE: $VM_ZONE âœ…"
          echo "- GCP_VM_EXTERNAL_IP: $VM_IP âœ…"
          echo "- SITE_URL: $SITE_URL âœ…"
          echo "- ENVIRONMENT: ${{ env.ENVIRONMENT }} âœ…"
          echo "- DOMAIN_NAME: ${{ env.DOMAIN_NAME }} âœ…"
          echo "- USE_DUCKDNS: ${{ env.USE_DUCKDNS }} âœ…"
          echo "- DUCKDNS_SUBDOMAIN: ${{ env.DUCKDNS_SUBDOMAIN }} âœ…"
          echo ""
          echo "ðŸ’¡ No deployment files created - all data stored in GitHub Variables for reliability"
          
          # Try to set GitHub Variables using REST API (with error handling)
          echo "ðŸ” Attempting to store as GitHub Variables..."
          
          # Determine which token to use for GitHub API
          echo "ðŸ” Determining authentication method..."
          if [ -n "${{ secrets.GH_PAT }}" ]; then
            echo "âœ… Using Personal Access Token (GH_PAT)"
            GITHUB_AUTH_TOKEN="${{ secrets.GH_PAT }}"
            TOKEN_TYPE="Personal Access Token"
          else
            echo "ðŸ“‹ Using default GITHUB_TOKEN (may have limited permissions)"
            GITHUB_AUTH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
            TOKEN_TYPE="Default GITHUB_TOKEN"
          fi
          
          # Test GitHub API permissions first
          echo "ðŸ§ª Testing GitHub API permissions with $TOKEN_TYPE..."
          api_test=$(curl -s -w "%{http_code}" -o /tmp/api_test.json \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_AUTH_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/actions/variables")
          
          api_code="${api_test: -3}"
          echo "ðŸ“¡ API Test Response: HTTP $api_code"
          
          if [ "$api_code" = "200" ]; then
            echo "âœ… GitHub API access confirmed with $TOKEN_TYPE"
          elif [ "$api_code" = "403" ]; then
            echo "âŒ GitHub API access denied (HTTP 403) with $TOKEN_TYPE"
            echo "ðŸ” This indicates insufficient permissions"
            
            if [ "$TOKEN_TYPE" = "Default GITHUB_TOKEN" ]; then
              echo ""
              echo "ï¿½ SOLUTION: Create and use a Personal Access Token"
              echo "ðŸ“‹ Steps to resolve:"
              echo "  1. Go to GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens"
              echo "  2. Create new token (classic) with these permissions:"
              echo "     â€¢ repo (Full control of private repositories)" 
              echo "     â€¢ workflow (Update GitHub Action workflows)"
              echo "  3. Add token as repository secret named 'GH_PAT'"
              echo "  4. Re-run this workflow"
              echo ""
              echo "ðŸ”— Direct link: https://github.com/settings/tokens/new"
            else
              echo ""
              echo "âŒ Even Personal Access Token was rejected"
              echo "ðŸ“‹ Possible issues:"
              echo "  1. Token may have expired"
              echo "  2. Token may not have required permissions"
              echo "  3. Repository may have additional restrictions"
            fi
          elif [ "$api_code" = "404" ]; then
            echo "âŒ Repository variables endpoint not found (HTTP 404)"
            echo "ðŸ“‹ This repository may not have Variables feature enabled"
          else
            echo "âš ï¸ Unexpected API response: HTTP $api_code"
            if [ -f /tmp/api_test.json ]; then
              echo "ðŸ“‹ Response: $(cat /tmp/api_test.json)"
            fi
          fi
          
          set +e  # Don't exit on error
          
          # Function to create or update GitHub Variable via REST API
          set_github_variable() {
            local var_name="$1"
            local var_value="$2"
            
            echo "ðŸ”„ Setting variable: $var_name"
            
            # Try to update existing variable first
            response=$(curl -s -w "%{http_code}" -o /tmp/gh_response.json \
              -X PATCH \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer $GITHUB_AUTH_TOKEN" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/actions/variables/$var_name" \
              -d "{\"name\":\"$var_name\",\"value\":\"$var_value\"}")
            
            http_code="${response: -3}"
            
            if [ "$http_code" = "204" ] || [ "$http_code" = "200" ]; then
              echo "âœ… Updated variable: $var_name"
              return 0
            elif [ "$http_code" = "404" ]; then
              # Variable doesn't exist, try to create it
              echo "ðŸ“ Variable doesn't exist, creating new one..."
              response=$(curl -s -w "%{http_code}" -o /tmp/gh_response.json \
                -X POST \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer $GITHUB_AUTH_TOKEN" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${{ github.repository }}/actions/variables" \
                -d "{\"name\":\"$var_name\",\"value\":\"$var_value\"}")
              
              http_code="${response: -3}"
              
              if [ "$http_code" = "201" ] || [ "$http_code" = "200" ]; then
                echo "âœ… Created variable: $var_name"
                return 0
              else
                echo "âš ï¸ Failed to create variable: $var_name (HTTP $http_code)"
                if [ -f /tmp/gh_response.json ]; then
                  echo "ðŸ“‹ Response: $(cat /tmp/gh_response.json)"
                fi
                return 1
              fi
            else
              echo "âš ï¸ Failed to update variable: $var_name (HTTP $http_code)"
              if [ -f /tmp/gh_response.json ]; then
                echo "ðŸ“‹ Response: $(cat /tmp/gh_response.json)"
              fi
              return 1
            fi
          }
          
          # Set infrastructure variables
          echo "ðŸ“Š Setting infrastructure variables..."
          set_github_variable "GCP_VM_INSTANCE" "$VM_NAME"
          set_github_variable "GCP_VM_ZONE" "$VM_ZONE"
          set_github_variable "GCP_VM_EXTERNAL_IP" "$VM_IP"
          set_github_variable "SITE_URL" "$SITE_URL"
          set_github_variable "ENVIRONMENT" "${{ env.ENVIRONMENT }}"
          
          # Set project variables
          set_github_variable "GCP_PROJECT_ID" "${{ env.GCP_PROJECT_ID }}"
          set_github_variable "DOMAIN_NAME" "${{ env.DOMAIN_NAME }}"
          
          # Duck DNS variables
          if [ "${{ env.USE_DUCKDNS }}" = "true" ]; then
            echo "ðŸ¦† Setting Duck DNS variables..."
            set_github_variable "USE_DUCKDNS" "true"
            set_github_variable "DUCKDNS_SUBDOMAIN" "${{ env.DUCKDNS_SUBDOMAIN }}"
          else
            set_github_variable "USE_DUCKDNS" "false"
          fi
          
          set -e  # Re-enable exit on error
          
          # Clean up temporary files
          rm -f /tmp/gh_response.json /tmp/api_test.json
          
          echo ""
          echo "âœ… Infrastructure details stored in deployment files!"
          echo ""
          echo "ðŸ“Š Storage Summary:"
          echo "âœ… Local deployment files: Always created successfully"
          echo "ðŸ” GitHub Variables: Attempted (check logs above for status)"
          echo ""
          echo "ðŸ’¡ Important Notes:"
          echo "- Deployment files (.deployment-info/) are the PRIMARY data source"
          echo "- GitHub Variables are a SECONDARY fallback for convenience"
          echo "- Other workflows will use deployment files first, then Variables"
          echo "- If Variable creation failed, workflows will still function correctly"
          echo ""
          echo "ðŸ“‹ Stored Information:"
          echo "- VM Instance: $VM_NAME"
          echo "- VM Zone: $VM_ZONE"
          echo "- External IP: $VM_IP"
          echo "- Site URL: $SITE_URL"
          echo "- Environment: ${{ env.ENVIRONMENT }}"
          echo ""
          echo "ðŸ“ Files created:"
          echo "- .deployment-info/infrastructure.json (detailed JSON)"
          echo "- .deployment-info/environment.env (shell variables)"
          echo ""
          echo "ðŸ” DNS Configuration:"
          echo "Configure your DNS provider with:"
          echo "- Type: A Record"
          echo "- Name: ${{ env.DOMAIN_NAME }}"
          echo "- Value: $VM_IP"
          echo "- TTL: 300 (5 minutes)"
          echo ""
          echo "ðŸ’¡ Other workflows can read these files to get infrastructure details"

      # Infrastructure provisioning completed - no files needed
      - name: ðŸŽ¯ Next Steps
        env:
          VM_NAME: ${{ steps.extract_outputs.outputs.vm_name }}
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
        run: |
          echo "ðŸŽ¯ Infrastructure provisioning completed successfully!"
          echo ""
          echo "ðŸš€ Next Steps:"
          echo "1. Run 'Install Packages' workflow to set up server software"
          echo "2. Run 'Configure Environment' workflow to set up WordPress"
          echo "3. Run 'Deploy Plugin' workflow to install Smart Gallery"
          echo ""
          echo "ðŸ’¡ All workflows will automatically use GitHub Variables (no file dependencies)"
          echo ""
          echo "ï¿½ VM Information:"
          echo "- Instance: $VM_NAME"
          echo "- External IP: $VM_IP"
          echo "- Status: Ready for package installation âœ…"

      # Verify DNS propagation (if Duck DNS is used)
      - name: ðŸ” Verify DNS Propagation
        if: env.USE_DUCKDNS == 'true'
        env:
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
        run: |
          echo "ðŸ” Checking DNS propagation for $DUCKDNS_SUBDOMAIN.duckdns.org..."
          
          # Wait a bit for initial propagation
          sleep 10
          
          # Try to resolve the domain
          for i in {1..6}; do
            RESOLVED_IP=$(nslookup $DUCKDNS_SUBDOMAIN.duckdns.org 2>/dev/null | grep "Address:" | tail -1 | awk '{print $2}')
            
            if [ "$RESOLVED_IP" = "$VM_IP" ]; then
              echo "âœ… DNS propagation successful!"
              echo "ðŸŒ $DUCKDNS_SUBDOMAIN.duckdns.org resolves to $VM_IP"
              break
            else
              echo "â³ DNS still propagating... (attempt $i/6)"
              if [ $i -lt 6 ]; then
                sleep 30
              else
                echo "âš ï¸ DNS propagation taking longer than expected"
                echo "ðŸ“‹ Expected: $VM_IP"
                echo "ðŸ“‹ Got: $RESOLVED_IP"
                echo "ðŸ•’ This is normal and should resolve within 5-10 minutes"
              fi
            fi
          done

            # SSH key generated and stored for all subsequent workflows
      - name: âœ… SSH Key Ready for All Workflows
        run: |
          echo "âœ… SSH key generated and configured for all workflows"
          echo "ðŸ”‘ VM_SSH_PRIVATE_KEY secret created for subsequent workflows"
          echo "ðŸš€ Next workflows (03, 04, 05) will automatically use this key"
          echo "ðŸ’¡ No manual SSH configuration needed - fully automated!"

      # Summary
      - name: ðŸ“Š Infrastructure Summary
        env:
          VM_NAME: ${{ steps.extract_outputs.outputs.vm_name }}
          VM_ZONE: ${{ steps.extract_outputs.outputs.vm_zone }}
          VM_IP: ${{ steps.extract_outputs.outputs.vm_external_ip }}
          SITE_URL: ${{ steps.extract_outputs.outputs.site_url }}
        run: |
          echo "## ðŸ—ï¸ Infrastructure Provisioning Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Resources Created:" >> $GITHUB_STEP_SUMMARY
          echo "- **VM Instance**: \`$VM_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Zone**: \`$VM_ZONE\`" >> $GITHUB_STEP_SUMMARY
          echo "- **External IP**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Site URL**: $SITE_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: \`${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.USE_DUCKDNS }}" = "true" ]; then
            echo "### ðŸ¦† Duck DNS Configuration:" >> $GITHUB_STEP_SUMMARY
            echo "âœ… **Duck DNS automatically configured!**" >> $GITHUB_STEP_SUMMARY
            echo "- **Domain**: \`${{ env.DUCKDNS_SUBDOMAIN }}.duckdns.org\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Points to**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: Active (propagation takes 1-5 minutes)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ” **Verify DNS**: \`nslookup ${{ env.DUCKDNS_SUBDOMAIN }}.duckdns.org\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ðŸŒ DNS Configuration Required:" >> $GITHUB_STEP_SUMMARY
            echo "Configure your DNS provider with an **A Record**:" >> $GITHUB_STEP_SUMMARY
            echo "- **Type**: A Record" >> $GITHUB_STEP_SUMMARY
            echo "- **Name**: \`${{ env.DOMAIN_NAME }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Value**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
            echo "- **TTL**: 300 (5 minutes)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ’¡ **Tip**: Consider using Duck DNS for easier setup!" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Stored GitHub Variables:" >> $GITHUB_STEP_SUMMARY
          echo "- \`GCP_VM_INSTANCE\`: $VM_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- \`GCP_VM_ZONE\`: $VM_ZONE" >> $GITHUB_STEP_SUMMARY  
          echo "- \`GCP_VM_EXTERNAL_IP\`: $VM_IP" >> $GITHUB_STEP_SUMMARY
          echo "- \`SITE_URL\`: $SITE_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. **Configure DNS** with your domain provider" >> $GITHUB_STEP_SUMMARY
          echo "2. Wait 5-10 minutes for DNS propagation" >> $GITHUB_STEP_SUMMARY
          echo "3. Run **Install Packages** workflow" >> $GITHUB_STEP_SUMMARY
          echo "4. Run **Configure Environment** workflow" >> $GITHUB_STEP_SUMMARY
          echo "5. Run **Deploy Plugin** workflow" >> $GITHUB_STEP_SUMMARY