name: "2. Provision infrastructure üèóÔ∏è"

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: 'GCP Project ID'
        required: true
        type: string
      domain_name:
        description: 'Domain name (e.g., smartgallery.exemplo.com or mysite.duckdns.org)'
        required: true
        type: string
      use_duckdns:
        description: 'Use Duck DNS for automatic DNS management'
        required: false
        default: false
        type: boolean
      duckdns_subdomain:
        description: 'Duck DNS subdomain (only the part before .duckdns.org)'
        required: false
        type: string
      environment:
        description: 'Environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      region:
        description: 'GCP Region'
        required: false
        default: 'us-central1'
        type: string
      machine_type:
        description: 'VM Machine Type'
        required: false
        default: 'e2-micro'
        type: choice
        options:
          - e2-micro
          - e2-small
          - e2-medium

env:
  TF_VERSION: '1.6.0'
  GCP_PROJECT_ID: ${{ github.event.inputs.project_id }}
  DOMAIN_NAME: ${{ github.event.inputs.domain_name }}
  ENVIRONMENT: ${{ github.event.inputs.environment }}
  USE_DUCKDNS: ${{ github.event.inputs.use_duckdns }}
  DUCKDNS_SUBDOMAIN: ${{ github.event.inputs.duckdns_subdomain }}

jobs:
  provision:
    name: üèóÔ∏è Terraform Provision
    runs-on: ubuntu-latest
    
    outputs:
      vm_name: ${{ steps.terraform.outputs.vm_name }}
      vm_zone: ${{ steps.terraform.outputs.vm_zone }}
      vm_external_ip: ${{ steps.terraform.outputs.vm_external_ip }}
      site_url: ${{ steps.terraform.outputs.site_url }}
    
    steps:
      # Checkout repository
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      # Setup Terraform
      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      # Authenticate to GCP
      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      # Setup Google Cloud SDK
      - name: ‚òÅÔ∏è Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      # Generate SSH key for VM access
      - name: üîë Generate SSH Key
        run: |
          mkdir -p ~/.ssh
          if [ ! -f ~/.ssh/id_rsa ]; then
            ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N ""
            echo "‚úÖ SSH key generated"
          fi
          
          # Store public key for later use
          echo "SSH_PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)" >> $GITHUB_ENV

      # Terraform Init
      - name: üèóÔ∏è Terraform Init
        working-directory: terraform
        run: |
          terraform init -upgrade
          echo "‚úÖ Terraform initialized"

      # Check for existing resources and import if needed
      - name: üîç Check Existing Resources
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
        run: |
          echo "üîç Checking for existing resources..."
          
          # Set environment variables for resource names
          NAME_PREFIX="smart-gallery-${{ env.ENVIRONMENT }}"
          
          # Function to safely import resources
          safe_import() {
            local resource_type="$1"
            local resource_name="$2"
            local gcp_resource_id="$3"
            
            echo "üîç Checking $resource_type: $resource_name"
            
            # Check if resource exists in state
            if terraform state show "$resource_type.$resource_name" >/dev/null 2>&1; then
              echo "‚úÖ $resource_name already in Terraform state"
              return 0
            fi
            
            # Check if resource exists in GCP and import if needed
            if gcloud compute $4 describe "$gcp_resource_id" --quiet >/dev/null 2>&1; then
              echo "üì• Importing existing $resource_name from GCP..."
              terraform import "$resource_type.$resource_name" "$gcp_resource_id" || {
                echo "‚ö†Ô∏è Import failed for $resource_name, will create new resource"
              }
            else
              echo "‚ûï $resource_name will be created"
            fi
          }
          
          # Import existing resources if they exist
          safe_import "google_compute_network" "smart_gallery_network" "$NAME_PREFIX-network" "networks"
          safe_import "google_compute_subnetwork" "smart_gallery_subnet" "${{ github.event.inputs.region }}/$NAME_PREFIX-subnet" "networks subnets"
          safe_import "google_compute_address" "smart_gallery_ip" "${{ github.event.inputs.region }}/$NAME_PREFIX-ip" "addresses"
          
          # For VM, check if it exists
          if gcloud compute instances describe "$NAME_PREFIX-vm" --zone="${{ github.event.inputs.region }}-a" --quiet >/dev/null 2>&1; then
            if ! terraform state show "google_compute_instance.smart_gallery_vm" >/dev/null 2>&1; then
              echo "üì• Importing existing VM from GCP..."
              terraform import "google_compute_instance.smart_gallery_vm" "${{ env.GCP_PROJECT_ID }}/${{ github.event.inputs.region }}-a/$NAME_PREFIX-vm" || {
                echo "‚ö†Ô∏è VM import failed, will try to manage existing resource"
              }
            else
              echo "‚úÖ VM already in Terraform state"
            fi
          else
            echo "‚ûï VM will be created"
          fi
          
          # Import firewall rules
          for fw_rule in "$NAME_PREFIX-allow-ssh" "$NAME_PREFIX-allow-http" "$NAME_PREFIX-allow-https" "$NAME_PREFIX-allow-icmp"; do
            if gcloud compute firewall-rules describe "$fw_rule" --quiet >/dev/null 2>&1; then
              if ! terraform state show "google_compute_firewall.${fw_rule//-/_}" >/dev/null 2>&1; then
                echo "üì• Importing firewall rule: $fw_rule"
                terraform import "google_compute_firewall.${fw_rule//-/_}" "${{ env.GCP_PROJECT_ID }}/$fw_rule" || {
                  echo "‚ö†Ô∏è Firewall import failed for $fw_rule"
                }
              fi
            fi
          done
          
          echo "‚úÖ Resource check completed"

      # Terraform Plan
      - name: üìã Terraform Plan
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
        run: |
          echo "üìã Creating Terraform plan..."
          terraform plan -out=tfplan -detailed-exitcode || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 2 ]; then
              echo "üìù Changes detected, plan created successfully"
            elif [ $EXIT_CODE -eq 1 ]; then
              echo "‚ùå Terraform plan failed"
              exit 1
            else
              echo "‚úÖ No changes needed"
            fi
          }
          echo "‚úÖ Terraform plan completed"

      # Terraform Apply
      - name: üöÄ Terraform Apply
        id: terraform
        working-directory: terraform
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_domain_name: ${{ env.DOMAIN_NAME }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ github.event.inputs.region }}
          TF_VAR_machine_type: ${{ github.event.inputs.machine_type }}
        run: |
          echo "üöÄ Applying Terraform configuration..."
          
          # Check if plan file exists and has changes
          if [ -f tfplan ]; then
            terraform apply -auto-approve tfplan
          else
            echo "‚ö†Ô∏è No plan file found, running direct apply..."
            terraform apply -auto-approve
          fi
          
          # Verify outputs exist before extracting them
          echo "üì§ Extracting Terraform outputs..."
          
          if terraform output vm_name >/dev/null 2>&1; then
            echo "vm_name=$(terraform output -raw vm_name)" >> $GITHUB_OUTPUT
          else
            # Fallback: construct VM name from variables
            VM_NAME="smart-gallery-${{ env.ENVIRONMENT }}-vm"
            echo "vm_name=$VM_NAME" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Using constructed VM name: $VM_NAME"
          fi
          
          if terraform output vm_zone >/dev/null 2>&1; then
            echo "vm_zone=$(terraform output -raw vm_zone)" >> $GITHUB_OUTPUT
          else
            # Fallback: use input zone
            VM_ZONE="${{ github.event.inputs.region }}-a"
            echo "vm_zone=$VM_ZONE" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Using constructed VM zone: $VM_ZONE"
          fi
          
          if terraform output vm_external_ip >/dev/null 2>&1; then
            echo "vm_external_ip=$(terraform output -raw vm_external_ip)" >> $GITHUB_OUTPUT
          else
            # Fallback: query GCP directly
            VM_IP=$(gcloud compute instances describe "smart-gallery-${{ env.ENVIRONMENT }}-vm" \
              --zone="${{ github.event.inputs.region }}-a" \
              --format="get(networkInterfaces[0].accessConfigs[0].natIP)" 2>/dev/null || echo "")
            echo "vm_external_ip=$VM_IP" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Retrieved VM IP directly from GCP: $VM_IP"
          fi
          
          if terraform output site_url >/dev/null 2>&1; then
            echo "site_url=$(terraform output -raw site_url)" >> $GITHUB_OUTPUT
          else
            # Fallback: construct from domain
            echo "site_url=https://${{ env.DOMAIN_NAME }}" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Using constructed site URL: https://${{ env.DOMAIN_NAME }}"
          fi
          
          echo "‚úÖ Infrastructure provisioned successfully!"

      # Wait for VM to be ready
      - name: ‚è≥ Wait for VM Startup
        env:
          VM_NAME: ${{ steps.terraform.outputs.vm_name }}
          VM_ZONE: ${{ steps.terraform.outputs.vm_zone }}
        run: |
          echo "‚è≥ Waiting for VM to complete startup..."
          
          # Wait up to 5 minutes for startup script completion
          for i in {1..30}; do
            if gcloud compute ssh $VM_NAME \
              --zone=$VM_ZONE \
              --command="test -f /var/log/startup-completed" \
              --quiet 2>/dev/null; then
              echo "‚úÖ VM startup completed!"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ö†Ô∏è Startup script may still be running"
              gcloud compute ssh $VM_NAME \
                --zone=$VM_ZONE \
                --command="tail -20 /var/log/startup-script.log" \
                --quiet || echo "Could not check startup log"
            fi
            
            echo "Waiting... (${i}/30)"
            sleep 10
          done

      # Configure Duck DNS automatically (if enabled)
      - name: ü¶Ü Configure Duck DNS
        if: env.USE_DUCKDNS == 'true'
        env:
          VM_IP: ${{ steps.terraform.outputs.vm_external_ip }}
          DUCKDNS_TOKEN: ${{ secrets.DUCKDNS_TOKEN }}
        run: |
          if [ -z "$DUCKDNS_TOKEN" ]; then
            echo "‚ùå DUCKDNS_TOKEN secret not found!"
            echo "Please add your Duck DNS token as a repository secret named DUCKDNS_TOKEN"
            echo "Get your token from: https://www.duckdns.org/"
            exit 1
          fi
          
          if [ -z "$DUCKDNS_SUBDOMAIN" ]; then
            echo "‚ùå Duck DNS subdomain not provided!"
            exit 1
          fi
          
          # Validate subdomain format (no special chars, reasonable length)
          if [[ ! "$DUCKDNS_SUBDOMAIN" =~ ^[a-zA-Z0-9-]{1,63}$ ]]; then
            echo "‚ùå Invalid Duck DNS subdomain format: $DUCKDNS_SUBDOMAIN"
            echo "Subdomain must contain only letters, numbers, and hyphens (1-63 chars)"
            echo "Examples: mysite, smart-gallery, test123"
            exit 1
          fi
          
          echo "ü¶Ü Configuring Duck DNS for $DUCKDNS_SUBDOMAIN.duckdns.org..."
          echo "üìç Setting IP to: $VM_IP"
          echo "üîç Using token: ${DUCKDNS_TOKEN:0:8}... (masked)"
          
          # Test Duck DNS API first
          echo "üß™ Testing Duck DNS API connectivity..."
          TEST_RESPONSE=$(curl -s -w "%{http_code}" -o /dev/null "https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=$DUCKDNS_TOKEN&txt=test")
          if [ "$TEST_RESPONSE" != "200" ]; then
            echo "‚ùå Cannot reach Duck DNS API. HTTP status: $TEST_RESPONSE"
            echo "Please check your internet connection or try again later"
            exit 1
          fi
          
          # Update Duck DNS with detailed error handling
          echo "üîÑ Updating Duck DNS record..."
          RESPONSE=$(curl -s "https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=$DUCKDNS_TOKEN&ip=$VM_IP")
          
          echo "üì° Duck DNS API Response: $RESPONSE"
          
          if [ "$RESPONSE" = "OK" ]; then
            echo "‚úÖ Duck DNS updated successfully!"
            echo "üåê Your domain $DUCKDNS_SUBDOMAIN.duckdns.org now points to $VM_IP"
            echo ""
            echo "üïí DNS propagation typically takes 1-5 minutes"
            echo "üîç You can check with: nslookup $DUCKDNS_SUBDOMAIN.duckdns.org"
          elif [ "$RESPONSE" = "KO" ]; then
            echo "‚ùå Duck DNS update failed with 'KO' response"
            echo ""
            echo "üîç Common causes:"
            echo "1. ‚ùå Invalid Duck DNS token"
            echo "2. ‚ùå Subdomain doesn't exist or not owned by this token"
            echo "3. ‚ùå Subdomain name format issue"
            echo ""
            echo "üõ†Ô∏è Troubleshooting steps:"
            echo "1. Visit https://www.duckdns.org/ and log in"
            echo "2. Verify your token matches the one in GitHub Secrets"
            echo "3. Check that subdomain '$DUCKDNS_SUBDOMAIN' exists in your account"
            echo "4. If subdomain doesn't exist, create it first"
            echo "5. Test manually: curl 'https://www.duckdns.org/update?domains=$DUCKDNS_SUBDOMAIN&token=YOUR_TOKEN&ip=$VM_IP'"
            echo ""
            echo "üìã Current values:"
            echo "- Subdomain: $DUCKDNS_SUBDOMAIN"
            echo "- Full domain: $DUCKDNS_SUBDOMAIN.duckdns.org"
            echo "- Target IP: $VM_IP"
            echo "- Token (first 8 chars): ${DUCKDNS_TOKEN:0:8}..."
            exit 1
          else
            echo "‚ùå Unexpected Duck DNS response: $RESPONSE"
            echo "Please check Duck DNS service status or try again later"
            exit 1
          fi

      # Store infrastructure details as GitHub Variables
      - name: üíæ Store Infrastructure Details
        env:
          VM_NAME: ${{ steps.terraform.outputs.vm_name }}
          VM_ZONE: ${{ steps.terraform.outputs.vm_zone }}
          VM_IP: ${{ steps.terraform.outputs.vm_external_ip }}
          SITE_URL: ${{ steps.terraform.outputs.site_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üíæ Storing infrastructure details as GitHub Variables..."
          
          # Store VM details for use in other workflows
          gh variable set GCP_VM_INSTANCE --body "$VM_NAME" --repo ${{ github.repository }}
          gh variable set GCP_VM_ZONE --body "$VM_ZONE" --repo ${{ github.repository }}
          gh variable set GCP_VM_EXTERNAL_IP --body "$VM_IP" --repo ${{ github.repository }}
          gh variable set SITE_URL --body "$SITE_URL" --repo ${{ github.repository }}
          gh variable set ENVIRONMENT --body "${{ env.ENVIRONMENT }}" --repo ${{ github.repository }}
          
          # Store Duck DNS info if used
          if [ "${{ env.USE_DUCKDNS }}" = "true" ]; then
            gh variable set USE_DUCKDNS --body "true" --repo ${{ github.repository }}
            gh variable set DUCKDNS_SUBDOMAIN --body "${{ env.DUCKDNS_SUBDOMAIN }}" --repo ${{ github.repository }}
          else
            gh variable set USE_DUCKDNS --body "false" --repo ${{ github.repository }}
          fi
          
          echo "‚úÖ Infrastructure details stored successfully!"
          echo ""
          echo "üìã Stored Variables:"
          echo "- GCP_VM_INSTANCE: $VM_NAME"
          echo "- GCP_VM_ZONE: $VM_ZONE"
          echo "- GCP_VM_EXTERNAL_IP: $VM_IP"
          echo "- SITE_URL: $SITE_URL"
          echo "- ENVIRONMENT: ${{ env.ENVIRONMENT }}"
          echo ""
          echo "üîç DNS Configuration:"
          echo "Configure your DNS provider with:"
          echo "- Type: A Record"
          echo "- Name: ${{ env.DOMAIN_NAME }}"
          echo "- Value: $VM_IP"
          echo "- TTL: 300 (5 minutes)"

      # Verify DNS propagation (if Duck DNS is used)
      - name: üîç Verify DNS Propagation
        if: env.USE_DUCKDNS == 'true'
        env:
          VM_IP: ${{ steps.terraform.outputs.vm_external_ip }}
        run: |
          echo "üîç Checking DNS propagation for $DUCKDNS_SUBDOMAIN.duckdns.org..."
          
          # Wait a bit for initial propagation
          sleep 10
          
          # Try to resolve the domain
          for i in {1..6}; do
            RESOLVED_IP=$(nslookup $DUCKDNS_SUBDOMAIN.duckdns.org 2>/dev/null | grep "Address:" | tail -1 | awk '{print $2}')
            
            if [ "$RESOLVED_IP" = "$VM_IP" ]; then
              echo "‚úÖ DNS propagation successful!"
              echo "üåê $DUCKDNS_SUBDOMAIN.duckdns.org resolves to $VM_IP"
              break
            else
              echo "‚è≥ DNS still propagating... (attempt $i/6)"
              if [ $i -lt 6 ]; then
                sleep 30
              else
                echo "‚ö†Ô∏è DNS propagation taking longer than expected"
                echo "üìã Expected: $VM_IP"
                echo "üìã Got: $RESOLVED_IP"
                echo "üïí This is normal and should resolve within 5-10 minutes"
              fi
            fi
          done

      # Store SSH private key as secret for next workflows
      - name: üîê Store SSH Key
        run: |
          echo "üíæ SSH private key stored for subsequent workflows"
          # In real scenario, you'd store this in a secure way
          # For now, we'll use gcloud ssh which handles keys automatically

      # Summary
      - name: üìä Infrastructure Summary
        env:
          VM_NAME: ${{ steps.terraform.outputs.vm_name }}
          VM_ZONE: ${{ steps.terraform.outputs.vm_zone }}
          VM_IP: ${{ steps.terraform.outputs.vm_external_ip }}
          SITE_URL: ${{ steps.terraform.outputs.site_url }}
        run: |
          echo "## üèóÔ∏è Infrastructure Provisioning Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Resources Created:" >> $GITHUB_STEP_SUMMARY
          echo "- **VM Instance**: \`$VM_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Zone**: \`$VM_ZONE\`" >> $GITHUB_STEP_SUMMARY
          echo "- **External IP**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Site URL**: $SITE_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: \`${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ env.USE_DUCKDNS }}" = "true" ]; then
            echo "### ü¶Ü Duck DNS Configuration:" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Duck DNS automatically configured!**" >> $GITHUB_STEP_SUMMARY
            echo "- **Domain**: \`${{ env.DUCKDNS_SUBDOMAIN }}.duckdns.org\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Points to**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: Active (propagation takes 1-5 minutes)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üîç **Verify DNS**: \`nslookup ${{ env.DUCKDNS_SUBDOMAIN }}.duckdns.org\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### üåê DNS Configuration Required:" >> $GITHUB_STEP_SUMMARY
            echo "Configure your DNS provider with an **A Record**:" >> $GITHUB_STEP_SUMMARY
            echo "- **Type**: A Record" >> $GITHUB_STEP_SUMMARY
            echo "- **Name**: \`${{ env.DOMAIN_NAME }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Value**: \`$VM_IP\`" >> $GITHUB_STEP_SUMMARY
            echo "- **TTL**: 300 (5 minutes)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üí° **Tip**: Consider using Duck DNS for easier setup!" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Stored GitHub Variables:" >> $GITHUB_STEP_SUMMARY
          echo "- \`GCP_VM_INSTANCE\`: $VM_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- \`GCP_VM_ZONE\`: $VM_ZONE" >> $GITHUB_STEP_SUMMARY  
          echo "- \`GCP_VM_EXTERNAL_IP\`: $VM_IP" >> $GITHUB_STEP_SUMMARY
          echo "- \`SITE_URL\`: $SITE_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üéØ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. **Configure DNS** with your domain provider" >> $GITHUB_STEP_SUMMARY
          echo "2. Wait 5-10 minutes for DNS propagation" >> $GITHUB_STEP_SUMMARY
          echo "3. Run **Install Packages** workflow" >> $GITHUB_STEP_SUMMARY
          echo "4. Run **Configure Environment** workflow" >> $GITHUB_STEP_SUMMARY
          echo "5. Run **Deploy Plugin** workflow" >> $GITHUB_STEP_SUMMARY